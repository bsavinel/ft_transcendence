En gros faut mettre tous les HTTP endpoints du 
channels.controller dans le gateway

1) Le user se logg 42 => Le socket client est instancié
2) Le gateway recoit du coup  un event on('connection') => { 
	{
		client.join(room)
		il fait join au socket client toutes les rooms dont
		il fait parti, cad all this user suscribed channels,
		et all this user private convos.
	}
	(bonus) {
		on emit a tout le monde le status en ligne de ce
		user cad: le server doit emit 
		someoneLoggedIn(this.user) a tout le monde 
		(pour set les users status en ligne / deco)
		et inversement someoneDisconnected(this.user)
	}
}
3) Le client doit maintenant listen les events: {
	{ STATUS (bonus) 
		cliSocket.on('someoneLoggedIn') pour set le tableau
		d'amis (hook/ref) avec leur status (?) et sa contrepartie

		cliSocket.on('someoneDisconnected')
	}
	{ MESSAGING
		cliSocket.on('serverBroadcastMsg') pour recevoir 
		tous les messages que le server lui envoit (cad les
		privates messages en directon de this user et les
		messages recus dans les this user susccribed channels
		moins ceux des blocked users)

		cliSocket.emit('sendMsg', msg, chanId)

		server.on('sendMsg', msg, chanId) => 
			check if user emetteur has n'est ni ban ni muted
			add msg to db
			server.to(chanId).emit(msg, emetteurId) MAIS (?)
			la ca envoit le msg meme a ceux qui on block l'emmetter??
			d'ou l'interet de faire une map de clients etc
	}
	{ BAN
		cliSocket.on('someoneHasBeenBanned', targetId) pour 
		annoncer a tout le monde de ce channel qu'un user s'est 
		fait ban. 
		if (targetId === this.user) {
			afficher l'alerte 'you have beend banned from this channel'
			et enlever le channel de sa liste affichée.
		} else {
			enlever le targetId utilisateur de la liste affichée
			des users de ce channel (bonus)
		}

		clientSocket.emit('banSomeone', targetId, chanId) pour la contrepartie,
		quand un creator ou un admin veut ban un user (targetId) 
		du channel et donc le signaler au back.

		server.on('banSomeone', targetId, chanId) pour catch et process le
		bannissement, cad: 
			verifier les droits de l'utilisateur emitteur (mais
			normalement le front ne devrait pas afficher le bouton
			si this user pas creator/admin)
			change roleChannel du targetId from USER to BAN,
			delete le targetId du channel, 
			server.to(chanId).emit('someoneHasBeenBanned', targetId)
			...(?)
	}
	{ ADMIN RIGHTS
		cliSocket.emit('giveRights', targetId, chanId) pour permettre à
		un creator (et admin?) de set un autre user en admin.

		server.on('giveRights', targetId, chanId) =>
			check les rights du user emitteur,
			check if targetId is in chan and not banned from it
			change targetId role from USER to ADMIN

		server.to(targetId socketId if co).emit('youHaveBeenPromoted');

		cliSocket.on('youHaveBeenPromoted') pour pouvoir afficher les 
		action buttons, dans la chatRoom (et/ou sur liste des users presents),
		de kick, ban, et mute.

		+ les crontreparties removeRights (attention il y a un check
		en plus c'est qu'un admin ne peut remove un creator's rights)
		et demote
	}
	{ ERROR
		clientSocket.on('error')
		server.emit('error')
	}
	{ ADD/REMOVE FRIENDS
	}
	{ INVITE PLAY GAME
	}	
	{ MUTE / UNMUTE
	}
	{ CREATE CHAN
		ATTENTION si chan is PRIVATE alors il faut desuite faire
		join l'autre utilisateur au truc (si il est co, si il est pas
		co c'est pas grave du coup ca lui fera auto join)
		SAUF si c'est un friend qui lui envoi le premier message, parce 
		que on a dit que quand on instancié le socket dans le front apres
		le logging on fesait auto join le gars à tous ses suscribed channels
		et à tous ses friends. (?)
	}
	{ JOIN CHAN
	}
}
4) Le client se deco ... etc

TODO: créer un composant pour l'alerte 'You have been banned from this channel'
BONUS: créer un composant qui liste les users du selected channel et leur status
TODO: créer un lien sur l'avatar d'un user vers son profil, ou encore en model qui
s'affiche avec les infos du gars (une preview de son profil), un lien vers sa page
de profil, et les bouttons kick/ban/mute etc 

TODO: setup l'access token dans l'instance client et faire le guard dans le back

trucs sympas socket: on peut donner une fct callback, lorsque le client emit
vers le server. Le server recoit l'event, le traite et peut alors appeler cette
fonction callback;

cliSocket.emit('eventName', data, callback => {doSomething(onSomething)});
server.on('eventName', (data, callback) => {
		things the server should do
		...
		pour utiliser/appeler la callback fct du client:
		return (onSomething);
	});

Use cases: quand le mec join un channel, le callback serait de setChannelsList(returnedChan);

TODO: install @socket.io/admin-ui pour pouvoir tester/voir les sockets/rooms/ns etc
